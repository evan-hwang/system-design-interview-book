# CH. 7 GUID 생성기



## 목적

엄청난 수의 사용자들을 감당하기 위해 다중 서버 시스템에서는 매분마다 수십, 수백만 개의 게임 객체를 생성, 파괴해야 할 수 있으며, 그중 일부는 데이터베이스에 저장하거나 데이터베이스에 담긴 것들과 동기화 하기도 한다

그리고 이는 게임 서버들 사이의 게임 객체 동기화를 어렵게 만드는 요인으로 작용한다

이런 문제 때문에 온라인 게임의 객체 시스템은 GUID(Global Unique Identifier) 생성 기능을 반드시 갖출 필요가 있다

GUID에 객체의 종류나 객체의 생성 시간 등과 같은 유용한 정보를 포함시킨다면 객체를 고유하게 식별하는 것 이외에 객체를 추적하고 관리하는 용도로 GUID를 효과적으로 활용할 수 있다

auto_increment를 그대로 쓸수는 없을까?

- 요구사항을 감당 하기 힘들다
  - insert 및 DBMS의 한계
  - 여러 DB를 쓰는 경우 delay를 낮추기가 힘들다 - 쓰기 동기화



## 1단계 문제 이해 및 설계 범위 확정

```
ID는 어떤 특성을 가지는가?
- ID는 유일해야 하고, 정렬 가능해야 함

새로운 레코드에 붙일 ID는 항상 1만큼 커져야 하는가?
- ID 값은 시간에 따라 커질 테지만 언제나 1씩 증가한다고 할 수는 없음
- 확실한 것은 시간에 따라 아침에 만든 ID 보다는 저녁에 만든 ID가 큰 값을 가진다

ID는 숫자로만 구성되어야 한다
시스템 규모는?
- 초당 10,000개의 ID를 만들 수 있어야 한다
```



## 2단계 개략적인 설계안 제시 및 동의 구하기

### 다중 마스터 복제(multi master replication)

auto increment 활용

- 1씩 증가시키는 것이 아닌 k만큼 증가 시킴

그림

장점

- DBMS 인스턴스 수에 따라 초당 생산 가능한 ID 수를 늘릴 수 있음
- 별도의 과정 없이 ID를 사용할 수 있다

단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
- ID의 유일성은 보장되지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없음
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다
- ORM의 경우 Destination 설정이 필요할 수 있다

### UUID(Universally Unique Identifier)

유일성이 보장되는 ID를 만드는 방법

- 128 bit 식별키, 충돌 가능성이 낮음

장점

- 보장된 알고리즘
- 서버간 조율 없이 독립적으로 생성 가능(동기화 불필요)

단점

- ID 길이가 128비트로 길다. 이번장의 요구사항은 64비트
  - 계산, 트래픽양 등 부수 효과도 존재
- ID를 시간순으로 정렬할 수 없다
- ID에 숫자(numeric)가 아닌 값이 포함될 수 있음

### 티켓 서버(ticket server)

유일성이 보장되는 ID를 만들어 내는 데 쓰이는 방법

- 플리커(Flickr)는 분산 기본 키(distriuted primary key)를 만들어 내기 위해 이 기술을 이용
- auto_increment 기능을 갖춘 데이터베이스, 티켓 서버를 중앙 집중형으로 하나만 사용하는 것

장점

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들수 있음
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합

단점

- 티켓서버가 SPOF가 된다
- 해당 서버의 오류 발생 시 모든 시스템이 영향을 받는다
  - 장애 발생 및 복원 시 데이터 동기화 이슈가 발생할 가능성이 존재

그림

### 트위터 스노우 플레이크(twitter snowflake)

솔류션에 근접, 생성해야 하는 ID의 구조를 여러 절(section)로 분할

그림

1 : 41 : 5 : 5 : 12

S:T41:DC5:SI5:SEQ:12

사인 비트(1)

- 음수 양수 구별, 나중을 위해 유보 (버퍼)

타임스탬프(41)

- 기원시간(epoch) 이후 밀리초 경과했는지를 나타내는 값
- 특정 시작 값을 기준으로 경과 시간 설정

데이터선터 ID

- 2^5 = 32개의 데이터 센터 표현

서버 ID

- 5비트 할당 데이터 센터당 32개의 서버 사용

일련번호

- 12비트를 할당 : 2^12=4096
- timeStampPeriod당 4096개 생성
- period 경과 할 때마다 0으로 초기화



## 3단계 상세 설계

데이터 센터 ID와 서버 ID는 시스템이 시작할때 결정되며 일반적으로 시스템 운영중에 바뀌지 않음

- 해당 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있으므로 그런 작업을 해야 할때 신중해야 함
- 타임 스템프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값



### 타임스탬프

가장 큰 41비트를 차지하고 있음, 시간에 따라 점점 큰 값을 갖게 됨

- ID는 시간 순으로 정렬 가능
- 2^41-1 = 2199023255551ms = 약 69년
- 기원 시간을 현재에 가깝게 맞춰서 오버플로(overflow) 발생을 늦출 수 있음

해당 시간이 지나면 기원 시간을 바꾸거나 ID 체계를 다른 것으로 이전(migration)해야 함



### 일련번호

2^12 = 4096

- 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 가지게 됨



## 4단계 마무리

시계 동기화 (clock synchronization)

- 전부 같은 시계를 사용한다는 가정하에 구현
- **하나의 서버가 여러 코어에 실행되는 경우 유효하지 않을 수 있다**
- NTP(Network Time Protocol)은 이 문제를 해결하는데 가장 보편적인 수단

```
인터넷을 통해 컴퓨터 시간을 최상위 동기 클럭원(Master Clock)에 동기화 시키는 프로토콜
- 네트워크 상에 분산된 시간 서버들로부터 클라이언트(호스트, 라우터 등)의 동기화
- 연관된 장비들의 시간을 인터넷상으로 동기화 하여 모든 장비의 시간을 동일하게 만들어 주는 통신
- 최소 0.001초 단위까지 동기화 가능 (UTC 기반)
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c92f3a2b-6a3d-4e50-a50c-512787cf82f0/Untitled.png)

더보기

- https://guslabview.tistory.com/452

**AWS Time Sync Service - 2017.12.17**

```
오늘부터 각 리전에서 멀티 위성 연결 및 원자 시계 플릿을 사용하여 매우 정확한 기준 시계를 제공하고 NTP(Network Time Protocol)를 통해 제공되는 시간 동기화 서비스인 Amazon Time Sync Service를 시작합니다. 이 서비스는 추가 비용 없이 제공되며 모든 퍼블릭 AWS 리전에서 VPC에서 실행 중인 모든 인스턴스에 즉시 사용할 수 있습니다.

ntpd를 사용해야 할 특별한 이유가 없다면 Chrony를 사용하는 것이 좋습니다

Amazon Time Sync Service는 VPC에서 실행 중인 모든 인스턴스의 169.254.169.123 IPv4 주소 또는 fd00:ec2::123 IPv6 주소에서 NTP를 통해 제공됩니다. IPv6 주소는 Nitro 시스템에 구축된 인스턴스에서만 액세스할 수 있습니다. 인스턴스에서 인터넷 액세스가 필요하지 않기 때문에 액세스를 허용하도록 보안 그룹 규칙이나 네트워크 ACL 규칙을 구성할 필요가 없습니다. 최신 버전의 Amazon Linux 2 및 Amazon Linux AMI는 기본적으로 Amazon Time Sync Service와 동기화됩니다.
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3b3bed7-1586-4e44-a6da-b1a940cc61b4/Untitled.png)

[time sync part1](https://aws.amazon.com/ko/blogs/mt/manage-amazon-ec2-instance-clock-accuracy-using-amazon-time-sync-service-and-amazon-cloudwatch-part-1/)

[time sync part2](https://aws.amazon.com/ko/blogs/mt/manage-amazon-ec2-instance-clock-accuracy-using-amazon-time-sync-service-and-amazon-cloudwatch-part-2/)

컨테이너의 경우는?

- 호스트 기반으로 시간 동기화 설정을 권장

  `/etc/localtime:/etc/localtome:ro`

Fargate같은 PaaS 컴퓨팅은?

- 서비스 특성상 우리가 조작할 수 없음
- 그냥 써도 무방, 가까운 위치에서 HOST VM을 기준으로 동기화 되고 있음
- fireCracker = [AWS VM](https://aws.amazon.com/ko/blogs/korea/firecracker-lightweight-virtualization-for-serverless-computing/)

```
This is something you do not need to worry about.

You couldn't do anything about it even if you wanted to, because Fargate doesn't allow privileged containers, which is what is needed to adjust the host clock.

couldn't find any specific documentation about this, but it seems very likely that AWS uses their own NTP service for the Firecracker VMs which run Fargate containers. - stack overflow - 
```

각 절(section)의 길이 최적화

- 동시성(concurrency)이 낮고 수명이 긴 애플리케이션이라면 일련번호의 길이를 줄이고 타임 스탬프절의 길이를 늘리는 것이 효과적일 수도 있다

고가용성(HA)

- ID 생성기는 필수불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야 한다





## 게임 객체의 GUID

다른 도메인 관점

- 게임 객체 GUID가 갖추어야 할 사항과 그것을 만족하는 방법

  과거 사례

  - 2 split
    - 16비트 워드로 나눠서 관리
    - 바람의 나라를 필두로 과거의 MMORPG 32비트 ID 체게 사용
    - 짧게는 3개월 길게는 3년만에 32비트 공간이 모두 소진
  - 서비스 도중 ID를 대체하는 작업은 정말 괴롭고 힘든 일
    - 적어도 10년 이상은 사용할 수 있는 안정적인 공간이 필요하다는 교훈

  

### 효율성

복합적인 시간 값이나 MAC 주소로 128비트의 GUID를 생성하는 방법은 있음

- ID 하나에 16바이트나 사용하면 처리 시간 및 영속성 저장공간, 네트워크 대역폭등 많은 부분에서 비효율적
- 기존의 128bit 생성 방법은 초당 10000개 이상 생산할수 있는 객체 팩토리들에 사용하기에는 너무 복잡하다 좀더 감당하기 쉬운 크기의 자료 형식과 보다 간단한 생성 방법이 필요



### 전역적 고유성

온라인 게임에서 게임 객체들은 여러 시스템들 사이에 이동하며 동기화. 따라서 ID가 지역적으로만(이를 생성한 시스템 내부) 고유하다면 시스템들 사이의 동기화 과정에서 ID 충돌을 피할수 없다

- 서로 다른 게임 객체가 같은 ID를 가지게 되면?

- 가장 큰 문제는 그러한 오류가 생기면 그 원인을 찾기가 매우 힘들어지며 고치기는 더 힘들어진다

- 문제 정의

  - 과거와 미래의 ID들의 고유성(유일성)을 보장해야 한다 서로 다른 객체 팩토리들이 생성한 ID들의 고유성을 보장해야 한다 여러 데이터베이스들이나 시스템들에서 ID를 동기화 하는 경우, 그러한 데이터베이스들 사이에서 ID의 고유성을 보장해야 하며, 한 ID가 항상 동일한 게임 객체를 지칭해야 한다

- 해상도가 높지 않아도 된다면?

  - 객체에 대한 정보 추가

    ID가 지칭하는 게임 객체에 대한 정보를 ID 자체에 포함 시키면 그렇지 않은 경우에 비해 여러가지 이득이 있음

    - 게임 시스템의 오류 및 진단 정보에서 ID를 통해 의미론적 정보를 사용하여 오류 진단 기록이 유용해짐
    - ID에 포함된 객체 정보는 최근 유행하는 데이터 마이닝에 활용도 가능(아이템 인기도 및 사용자 영향에 의해서 발생한 속성들의 집계 등)
    - 담을 수 있는 정보로는 객체를 생성한 팩토리, 생성 시간, 객체의 종류등이 있음

  - Game ID Factory

    64비트 GUID

    - T 32 - 전역적인 보장
      - ID서버라고 부르는 하나의 전역 시스템이 객체 팩토리의 요구에 따라 생성
      - 시간 꼬리표의 생성은 ID 서버가 전담
    - B 32 - 지역적인 보장
      - 객체의 일련번호로 각 객체 팩토리가 생성
      - 객체 팩토리는 ID 서버가 발급한 시간 꼬리표와 자신이 생성한 일련번호를 연결해서 하나의 64비트 GUID 생성
      - 일련번호의 생성은 객체 팩토리가 전담하므로 구조가 간단하고 역할이 명확

  - 시간 꼬리표 생성

    시간 꼬리표는 20비트의 타임 스탬프와 12비트의 청크 번호로 구성

    **T32**

    - 0x TTTTT CCC - 20, 12비트
    - T : 타임스탬프, C: 청크번호

    게임이 20년 이상 서비스 될 것으로 예상한다면 타임 스탬프의 해상도를 낮추면 됨

    - 예를 들어 타임 스탬프를 20분마다 증가한다며 약 40년 동안 사용 가능
    - 청크번호는 타임스탬프가 같은 시간대의 누적 개수
    - 이것은 객체 팩토리가 ID서버에 시간 꼬리표를 요청할 때마다 증가
    - 타임스탬프가 증가하면 청크번호는 0x000으로 초기화 된다

    20년간 매 10분마다 4096개의 고유한 시간 꼬리표를 생성할 수 있음

    - 시간 꼬리표는 전역적으로 고유해야 하므로 시간 꼬리표를 발급하는 ID 서버는 단 하나만 존재해야 함
    - 현실적인 이유로 ID 서버를 하나만 둘 수 없는 경우
      - 한가지의 해결책으로 청크 번호의 비트 몇개를 각 ID 서버의 고유한 식별자를 담는 용도로 사용

  - 일련번호 생성

    **B32**

    - 0x OO RR IIII
    - O : 객체 종류, R: 예비 버퍼, I : 인스턴스 번호

    일련번호 생성. C들은 객체의 종류이고 R은 예비용, I는 인스턴스 번호

    - 객체의 형식 또는 종류를 담는 8비트
    - 예외 처리나 향후 용도를 위해 예비된 8 비트
    - 인스턴스 번호를 담는 16비트로 구성

  - 예외처리

    GUID에 관련된 요구사항의 예측 또는 문제 발생시 고민할 수 있는 처리

    ### 클라이언트 객체 팩토리에서 사용할 임시 ID 생성

    게임 객체들을 복제(동기화), 제어하기 위한 객체 팩토리를 따로 둘 수 도 있음

    - 일반적인 경우는 없음(해킹 위험)
    - 그러나 다른 프로세스들과는 동기화되지 않는 임시 게임 객체들을 생성해야 하는 경우도 생길 수 있음
    - 예를 들면 UI를 관리하거나 게임 객체가 로컬 이벤트에 반응하는 경우 등

    보안상의 문제를 피하면서 요구사항을 만족시키는 방법은?

    - 동기화가 필요한 객체와는 다른 형태의 ID를 해당 성격의 객체들에게 부여하는 것
    - 임시 게임 객체들에 대해서는 시간 꼬리표의 TimeStamp를 0x00000로 설정
    - 일련번호의 객체 종류 값도 동기화가 필요한 전역 객체와는 다른 방식으로 부여하는 방법

    ### 청크 번호 넘침

    청크 번호가 0xFFFF에 도달하면 청크 번호 넘침(overFlow) 발생

    - 인스턴스 번호를 너무 빨리 소진하거나 너무 많은 객체 팩토리들이 ID 서버에서 시간 꼬리표를 요청할 때 그런 일이 발생

    - 중요한 것은 

      이러한 예외 상황이 아예 생기지 않도록 하는것

       (버퍼의 소중함)

      - 될수 있으면 ID서버에 접근하는 객체 팩토리의 수를 제한 하는 것도 하나의 방법

    - 이런 경우에도 청크가 넘치는 경우가 발생할 수 있음

      - 그런 경우는 타임스탬프의 값을 증가하고 청크번호를 초기화하면 된다
      - 물론 적당히 시간이 지나 타임스탬프 값이 이미 증가 되었따면 다시 증가할 필요는 없다

    - 이를 미연에 방지하기 위해서는 대역폭을 어느정도 희생하더라도 특정 리미터(예로 0x8000)을 넘어가면 ID 서버에게 다음 시간 꼬리표를 미리 확보하는 것
